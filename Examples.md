# pyMovieFingerprint

moviefingerprint analyzes a video stream and returns an image that represents the movie's 'fingerprint'.  This fingerprint image is a unique type of image averaging that maintains the most common ambient colors and image patterns.

Each fingerprint image is produced by sampling frames from a video and applying some OpenCV image processing operations.  Those operations are described below:

- The video is sampled at a rate specified by the 'total_samples' value of the MovieFingerprint object (default is 250 per video).  OpenCV unfortunately forces you to read in each frame sequentially which is the largset bottleneck by far.
- If a frame is selected for sampling, it is then converted from BGR (OpenCV default color space, simply reordered RGB) to HSV (aka HSI).  BGR/RGB is a poor image format to perform most image arithmetic - it's much more convenient to work with HSV/HSI or YCrCb.  


- --------S and V channels histogram-equalized (lines 75, 76).  Converted back to BGR (77).  Gaussian blurred with 5X5 kernel (78). Added to resulting image (81).


- It also became clear early on the Histogram Equalization of each frame was required to prevent dark and bright spots from overwhelming the image.  The exact implementation was not as obvious.
- Image is normalized by converting each integer pixel value (all 3 channels) to float and then dividing by the total number of sampled frames (lines 60 and 81).  Without the normalization step, the pixel values would 'wrap' back to 0 when exceeding 2^8.
- Each sampled frame's color space is converted from BGR (reordered RGB) to HSV (line 74) - BGR/RGB is a poor image format to perform most image arithmetic.  It's much more convenient to work with HSV/HSI or YCrCb.  S and V channels histogram-equalized (lines 75, 76).  Converted back to BGR (77).  Gaussian blurred with 5X5 kernel (78). Added to resulting image (81).
- Once the entire movie has been sampled, the final image meets another 5X5 gaussian blur kernel (87) and is converted back to 8bit representation so it can be viewed.


>
```python
hsv_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2HSV)  # Convert BGR image to HSV
hsv_image[:, :, 1] = cv2.equalizeHist(hsv_image[:, :, 1])  # Histogram equalization of S channel; 0-H, 1-S, 2-V
```
>
Channelbreakdown with and without Histogram Equalization on each channel:
<img src=images/Layers_HistEQ.PNG width="1000">

- After lots experimentation, conversion to HSV color space, and then Histogram Equalization on the S and V channels was the best combination:
<img src=images/HistEQ_Channel_Comparison.PNG width="1000">


Below are a few example images generated by moviefingerprint:

Ghost in the Shell
![Ghost in the Shell](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Ghost%20in%20the%20Shell%20(1995).jpg)


Lawrence of Arabia
![Lawrence of Arabia](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Lawrence%20of%20Arabia.jpg)


Wild
![Wild](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Wild.jpg)


Twin Peaks - Fire Walk With Me
![Twin Peaks - Fire Walk With Me](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Twin%20Peaks%20-%20Fire%20Walk%20With%20Me.jpg)
