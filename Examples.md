# pyMovieFingerprint

pyMovieFingerprint analyzes a video stream and returns an image that represents the movie's 'fingerprint'.  This fingerprint image is a unique type of image averaging that maintains the most common ambient colors and image patterns.  

Below on the left is a moviefingerprint image from the movie [Moon](http://www.imdb.com/title/tt1182345/) and on the right is a scene from the same movie with similar image qualities.
<img src=images/Both_Moon.jpg width="1000">

Each fingerprint image is produced by sampling frames from a video and applying some OpenCV image processing operations.  Those operations are described below:

- The video is sampled at a rate specified by the 'total_samples' value of the MovieFingerprint object (default is 250 per video).  OpenCV unfortunately forces you to read in each frame sequentially which is the largset bottleneck by far.
- If a frame is selected for sampling, it is then converted from BGR color space (reordered RGB, OpenCV default) to HSV (aka HSI).  BGR/RGB is a poor image format to perform most image arithmetic - it's much more convenient to work with HSV/HSI or YCrCb.  
- After lots of experimentation, it was determined that the best method to preserve the color and intensity of a movie is to normalize the image, Histogram Equalize the S and V channels, liberal application of Gaussian Blur
    - Equalize the image by converting pixels to float values, divide by number of sample, convert back to 8 bit integer pixel values at the end.  Failure to do so will result in the pixel values wrapping back to 0 after surpassing 255 - lots of hot and dark spots all over the image
    - Histogram Equalize the S and V image channels.  Without this step, the image tends to trend toward and ugly brown/grey.  The H channel is skipped here because equalizing it results in unnaturally colorful blocky pixels - Also note that H and S channels are low resolution in compressed video but S tends to handle eualization more seemlessly. 
    - Gausiann blur helps blend the any edges in the image; better match for the abstract coloring

<br>
Let's take a look at what Histogram Equalization does to each channel (converted individually to greyscale):
>
```python
hsv_image = cv2.cvtColor(bgr_image, cv2.COLOR_BGR2HSV)  # Convert BGR image to HSV
hsv_image[:, :, 1] = cv2.equalizeHist(hsv_image[:, :, 1])  # Histogram equalization of S channel; 0-H, 1-S, 2-V
```
>
Channelbreakdown with and without Histogram Equalization on each channel:
<img src=images/Layers_HistEQ.PNG width="1000">

- After lots experimentation, conversion to HSV color space, and then Histogram Equalization on the S and V channels was the best combination:
<img src=images/HistEQ_Channel_Comparison.PNG width="1000">


Below are a few example images generated by moviefingerprint:

Ghost in the Shell
![Ghost in the Shell](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Ghost%20in%20the%20Shell%20(1995).jpg)


Lawrence of Arabia
![Lawrence of Arabia](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Lawrence%20of%20Arabia.jpg)


Wild
![Wild](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Wild.jpg)


Twin Peaks - Fire Walk With Me
![Twin Peaks - Fire Walk With Me](https://gitlab.com/danielorf/moviefingerprint/raw/master/images/Twin%20Peaks%20-%20Fire%20Walk%20With%20Me.jpg)
